From 2a07f632a6b4e789906618afdb7a1a4ec6cb7178 Mon Sep 17 00:00:00 2001
From: Antonio Nuno Monteiro <anmonteiro@gmail.com>
Date: Thu, 20 Apr 2023 00:20:26 -0700
Subject: [PATCH] feat(reactjs-jsx-ppx): react/jsx-runtime transform

---
 .github/workflows/opam-build.yml              |   1 +
 .../test/re_or_res/reactjs_ppx_custom.js      |  23 +-
 jscomp/test/re_or_res/reactjs_ppx_custom.re   |   5 +-
 reactjs-jsx-ppx/reactjs_jsx_ppx_v3.ml         | 285 +++++++++---------
 test/react.t                                  |   9 +-
 5 files changed, 168 insertions(+), 155 deletions(-)

diff --git a/.github/workflows/opam-build.yml b/.github/workflows/opam-build.yml
index 5dc0eb9889..5c6367dba5 100644
--- a/.github/workflows/opam-build.yml
+++ b/.github/workflows/opam-build.yml
@@ -69,6 +69,7 @@ jobs:
       - name: Build basic template
         working-directory: melange-opam-template
         run: |
+          npm install "https://github.com/reasonml/reason-react.git#anmonteiro/jsx-runtime" --legacy-peer-deps
           opam exec -- dune build @react @node --display=short
           npm run bundle
 
diff --git a/jscomp/test/dist/jscomp/test/re_or_res/reactjs_ppx_custom.js b/jscomp/test/dist/jscomp/test/re_or_res/reactjs_ppx_custom.js
index 9100e22fbe..e1d7a9017c 100644
--- a/jscomp/test/dist/jscomp/test/re_or_res/reactjs_ppx_custom.js
+++ b/jscomp/test/dist/jscomp/test/re_or_res/reactjs_ppx_custom.js
@@ -1,14 +1,30 @@
 // Generated by Melange
 'use strict';
 
-var React = require("react");
+var React = require("./react.js");
+var React$1 = require("react");
+
+function jsx(prim0, prim1) {
+  return React$1.createElement(prim0, prim1);
+}
+
+var React$2 = {
+  Ref: React.Ref,
+  Children: React.Children,
+  Context: React.Context,
+  Fragment: React.Fragment,
+  StrictMode: React.StrictMode,
+  Suspense: React.Suspense,
+  SuspenseList: React.SuspenseList,
+  jsx: jsx
+};
 
 function Reactjs_ppx_custom$Internal$header(Props) {
   throw {
         RE_EXN_ID: "Assert_failure",
         _1: [
           "reactjs_ppx_custom.re",
-          4,
+          7,
           21
         ],
         Error: new Error()
@@ -20,11 +36,12 @@ var Internal = {
 };
 
 function Reactjs_ppx_custom(Props) {
-  return React.createElement(Reactjs_ppx_custom$Internal$header, {});
+  return React$1.createElement(Reactjs_ppx_custom$Internal$header, {});
 }
 
 var make = Reactjs_ppx_custom;
 
+exports.React = React$2;
 exports.Internal = Internal;
 exports.make = make;
 /* react Not a pure module */
diff --git a/jscomp/test/re_or_res/reactjs_ppx_custom.re b/jscomp/test/re_or_res/reactjs_ppx_custom.re
index 83824a8ddc..4a718fdae9 100644
--- a/jscomp/test/re_or_res/reactjs_ppx_custom.re
+++ b/jscomp/test/re_or_res/reactjs_ppx_custom.re
@@ -1,4 +1,7 @@
-module React = React;
+module React = {
+  include React;
+  let jsx = createElement;
+};
 module Internal = {
   [@react.component]
   let header = () => assert(false);
diff --git a/reactjs-jsx-ppx/reactjs_jsx_ppx_v3.ml b/reactjs-jsx-ppx/reactjs_jsx_ppx_v3.ml
index 4690ba9fb1..9f432e00a0 100644
--- a/reactjs-jsx-ppx/reactjs_jsx_ppx_v3.ml
+++ b/reactjs-jsx-ppx/reactjs_jsx_ppx_v3.ml
@@ -33,7 +33,8 @@ let keyType loc =
 type 'a children = ListLiteral of 'a | Exact of 'a
 type componentConfig = { propsName : string }
 
-(* if children is a list, convert it to an array while mapping each element. If not, just map over it, as usual *)
+(* if children is a list, convert it to an array while mapping each element. If
+   not, just map over it, as usual *)
 let transformChildrenIfListUpper ~ctxt ~loc ~mapper theList =
   let rec transformChildren_ theList accum =
     (* not in the sense of converting a list to an array; convert the AST
@@ -70,7 +71,7 @@ let transformChildrenIfList ~ctxt ~loc ~mapper theList =
   in
   transformChildren_ theList []
 
-let extractChildren ?(removeLastPositionUnit = false) ~loc propsAndChildren =
+let extractChildren ?(removeLastPositionUnit = false) propsAndChildren =
   let rec allButLast_ lst acc =
     match lst with
     | [] -> []
@@ -96,10 +97,13 @@ let extractChildren ?(removeLastPositionUnit = false) ~loc propsAndChildren =
   with
   | [], props ->
       (* no children provided? Place a placeholder list *)
-      ( Exp.construct ~loc { loc; txt = Lident "[]" } None,
-        if removeLastPositionUnit then allButLast props else props )
+      (None, if removeLastPositionUnit then allButLast props else props)
+  | ( [ (_, { pexp_desc = Pexp_construct ({ txt = Lident "[]"; _ }, None) }) ],
+      props ) ->
+      (None, if removeLastPositionUnit then allButLast props else props)
   | [ (_, childrenExpr) ], props ->
-      (childrenExpr, if removeLastPositionUnit then allButLast props else props)
+      ( Some childrenExpr,
+        if removeLastPositionUnit then allButLast props else props )
   | _ ->
       raise
         (Invalid_argument "JSX: somehow there's more than one `children` label")
@@ -127,11 +131,13 @@ let hasAttr { attr_name = loc; _ } = loc.txt = "react.component"
 (* Helper method to filter out any attribute that isn't [@react.component] *)
 let otherAttrsPure { attr_name = loc; _ } = loc.txt <> "react.component"
 
-(* Iterate over the attributes and try to find the [@react.component] attribute *)
+(* Iterate over the attributes and try to find the [@react.component]
+   attribute *)
 let hasAttrOnBinding { pvb_attributes } =
   find_opt hasAttr pvb_attributes <> None
 
-(* Finds the name of the variable the binding is assigned to, otherwise raises Invalid_argument *)
+(* Finds the name of the variable the binding is assigned to, otherwise raises
+   Invalid_argument *)
 let getFnName binding =
   match binding with
   | { pvb_pat = { ppat_desc = Ppat_var { txt } } } -> txt
@@ -165,7 +171,8 @@ let getPropsNameValue _acc (loc, exp) =
           ^ Longident.last_exn txt))
   [@@raises Invalid_argument]
 
-(* Lookup the `props` record or string as part of [@react.component] and store the name for use when rewriting *)
+(* Lookup the `props` record or string as part of [@react.component] and store
+   the name for use when rewriting *)
 let getPropsAttr payload =
   let defaultProps = { propsName = "Props" } in
   match payload with
@@ -196,7 +203,8 @@ let getPropsAttr payload =
 let pluckLabelDefaultLocType (label, default, _, _, loc, type_) =
   (label, default, loc, type_)
 
-(* Lookup the filename from the location information on the AST node and turn it into a valid module identifier *)
+(* Lookup the filename from the location information on the AST node and turn it
+   into a valid module identifier *)
 let filenameFromLoc ~ctxt (pstr_loc : Location.t) =
   let fileName =
     match pstr_loc.loc_start.pos_fname with
@@ -210,7 +218,8 @@ let filenameFromLoc ~ctxt (pstr_loc : Location.t) =
   let fileName = String.capitalize_ascii fileName in
   fileName
 
-(* Build a string representation of a module name with segments separated by $ *)
+(* Build a string representation of a module name with segments separated by
+   $ *)
 let makeModuleName fileName nestedModules fnName =
   let fullModuleName =
     match (fileName, nestedModules, fnName) with
@@ -224,13 +233,12 @@ let makeModuleName fileName nestedModules fnName =
   let fullModuleName = String.concat "$" fullModuleName in
   fullModuleName
 
-(*
-  AST node builders
-  These functions help us build AST nodes that are needed when transforming a [@react.component] into a
-  constructor and a props external
-*)
+(* AST node builders These functions help us build AST nodes that are needed
+   when transforming a [@react.component] into a constructor and a props
+   external *)
 
-(* Build an AST node representing all named args for the `external` definition for a component's props *)
+(* Build an AST node representing all named args for the `external` definition
+   for a component's props *)
 let rec recursivelyMakeNamedArgsForExternal list args =
   match list with
   | (label, default, loc, interiorType) :: tl ->
@@ -262,7 +270,8 @@ let rec recursivelyMakeNamedArgsForExternal list args =
                        ({ txt = Ldot (Lident "*predef*", "option") }, [ type_ ]);
                  },
                _ )
-           (* ~foo: int=? - note this isnt valid. but we want to get a type error *)
+           (* ~foo: int=? - note this isnt valid. but we want to get a type
+              error *)
            | label, Some type_, _
              when isOptional label ->
                type_
@@ -315,7 +324,8 @@ let makePropsValue fnName loc namedArgListWithKeyAndRef propsType =
   }
   [@@raises Invalid_argument]
 
-(* Build an AST node representing an `external` with the definition of the [@bs.obj] *)
+(* Build an AST node representing an `external` with the definition of the
+   [@bs.obj] *)
 let makePropsExternal fnName loc namedArgListWithKeyAndRef propsType =
   {
     pstr_loc = loc;
@@ -334,7 +344,8 @@ let makePropsExternalSig fnName loc namedArgListWithKeyAndRef propsType =
   }
   [@@raises Invalid_argument]
 
-(* Build an AST node for the props name when converted to an object inside the function signature  *)
+(* Build an AST node for the props name when converted to an object inside the
+   function signature *)
 let makePropsName ~loc name =
   {
     ppat_desc = Ppat_var { txt = name; loc };
@@ -350,7 +361,8 @@ let makeObjectField loc (str, attrs, type_) =
     pof_attributes = attrs;
   }
 
-(* Build an AST node representing a "closed" object representing a component's props *)
+(* Build an AST node representing a "closed" object representing a component's
+   props *)
 let makePropsType ~loc namedTypeList =
   Typ.mk ~loc
     (Ptyp_constr
@@ -365,6 +377,47 @@ let makePropsType ~loc namedTypeList =
            };
          ] ))
 
+let jsxExprAndChildren ?(ident = "React") ~loc ~ctxt mapper ~keyProps children =
+  let childrenExpr =
+    Option.map (transformChildrenIfListUpper ~loc ~mapper ~ctxt) children
+  in
+  match (childrenExpr, keyProps) with
+  | Some (Exact children), _key :: _ ->
+      ( Exp.ident { loc = Location.none; txt = Ldot (Lident ident, "jsxKeyed") },
+        (* [|moreCreateElementCallsHere|] *)
+        Some children )
+  | Some (Exact children), [] ->
+      ( Exp.ident { loc = Location.none; txt = Ldot (Lident ident, "jsx") },
+        (* [|moreCreateElementCallsHere|] *)
+        Some children )
+  | Some (ListLiteral { pexp_desc = Pexp_array list }), _key :: _ when list = []
+    ->
+      ( Exp.ident { loc = Location.none; txt = Ldot (Lident ident, "jsxKeyed") },
+        (* [|moreCreateElementCallsHere|] *)
+        children )
+  | Some (ListLiteral { pexp_desc = Pexp_array list }), [] when list = [] ->
+      ( Exp.ident { loc = Location.none; txt = Ldot (Lident ident, "jsx") },
+        (* [|moreCreateElementCallsHere|] *)
+        children )
+  | Some (ListLiteral children), _key :: _ ->
+      (* this is a hack to support react components that introspect into their
+         children *)
+      ( Exp.ident { loc = Location.none; txt = Ldot (Lident ident, "jsxsKeyed") },
+        Some children )
+  | Some (ListLiteral children), [] ->
+      (* this is a hack to support react components that introspect into their
+         children *)
+      ( Exp.ident { loc = Location.none; txt = Ldot (Lident ident, "jsxs") },
+        Some children )
+  | None, _key :: _ ->
+      ( Exp.ident { loc = Location.none; txt = Ldot (Lident ident, "jsxKeyed") },
+        (* [|moreCreateElementCallsHere|] *)
+        None )
+  | None, [] ->
+      ( Exp.ident { loc = Location.none; txt = Ldot (Lident ident, "jsx") },
+        (* [|moreCreateElementCallsHere|] *)
+        None )
+
 (* Builds an AST node for the entire `external` definition of props *)
 let makeExternalDecl fnName loc namedArgListWithKeyAndRef namedTypeList =
   makePropsExternal fnName loc
@@ -374,37 +427,25 @@ let makeExternalDecl fnName loc namedArgListWithKeyAndRef namedTypeList =
 
 (* TODO: some line number might still be wrong *)
 let jsxMapper =
-  let jsxVersion = ref None in
-
   let transformUppercaseCall3 ~caller modulePath ~ctxt mapper loc attrs _
       callArguments =
-    let children, argsWithLabels =
-      extractChildren ~loc ~removeLastPositionUnit:true callArguments
-    in
+    let children, argsWithLabels = extractChildren callArguments in
     let argsForMake = argsWithLabels in
-    let childrenExpr =
-      transformChildrenIfListUpper ~loc ~mapper ~ctxt children
+    let keyProps, otherProps =
+      List.partition
+        (fun (arg_label, _) -> "key" = getLabel arg_label)
+        argsForMake
     in
-    let recursivelyTransformedArgsForMake =
-      argsForMake
+    let jsxExpr, childrenProp =
+      jsxExprAndChildren ~loc ~ctxt mapper ~keyProps children
+    in
+    let propsArg =
+      (match childrenProp with
+      | Some childrenProp -> (labelled "children", childrenProp) :: otherProps
+      | None -> otherProps)
       |> List.map (fun (label, expression) ->
              (label, mapper#expression ctxt expression))
     in
-    let childrenArg = ref None in
-    let args =
-      recursivelyTransformedArgsForMake
-      @ (match childrenExpr with
-        | Exact children -> [ (labelled "children", children) ]
-        | ListLiteral { pexp_desc = Pexp_array list } when list = [] -> []
-        | ListLiteral expression ->
-            (* this is a hack to support react components that introspect into their children *)
-            childrenArg := Some expression;
-            [
-              ( labelled "children",
-                Exp.ident ~loc { loc; txt = Ldot (Lident "React", "null") } );
-            ])
-      @ [ (nolabel, Exp.construct ~loc { loc; txt = Lident "()" } None) ]
-    in
     let isCap str =
       let first = String.sub str 0 1 [@@raises Invalid_argument] in
       let capped = String.uppercase_ascii first in
@@ -428,83 +469,40 @@ let jsxMapper =
                "JSX name can't be the result of function applications")
     in
     let props =
-      Exp.apply ~attrs ~loc (Exp.ident ~loc { loc; txt = propsIdent }) args
+      Exp.apply ~attrs ~loc (Exp.ident ~loc { loc; txt = propsIdent }) propsArg
     in
-    (* handle key, ref, children *)
-    (* React.createElement(Component.make, props, ...children) *)
-    match !childrenArg with
-    | None ->
-        Exp.apply ~loc ~attrs
-          (Exp.ident ~loc { loc; txt = Ldot (Lident "React", "createElement") })
-          [ (nolabel, Exp.ident ~loc { txt = ident; loc }); (nolabel, props) ]
-    | Some children ->
-        Exp.apply ~loc ~attrs
-          (Exp.ident ~loc
-             { loc; txt = Ldot (Lident "React", "createElementVariadic") })
-          [
-            (nolabel, Exp.ident ~loc { txt = ident; loc });
-            (nolabel, props);
-            (nolabel, children);
-          ]
-    [@@raises Invalid_argument]
+    Exp.apply ~loc ~attrs jsxExpr
+      ([ (nolabel, Exp.ident ~loc { txt = ident; loc }); (nolabel, props) ]
+      @ List.map (fun (_, v) -> (nolabel, v)) keyProps)
   in
 
   let transformLowercaseCall3 ~ctxt mapper loc attrs callArguments id =
-    let children, nonChildrenProps = extractChildren ~loc callArguments in
+    let children, nonChildrenProps = extractChildren callArguments in
     let componentNameExpr = constantString ~loc id in
-    let childrenExpr = transformChildrenIfList ~loc ~ctxt ~mapper children in
-    let createElementCall =
-      match children with
-      (* [@JSX] div(~children=[a]), coming from <div> a </div> *)
-      | {
-       pexp_desc =
-         ( Pexp_construct
-             ({ txt = Lident "::" }, Some { pexp_desc = Pexp_tuple _ })
-         | Pexp_construct ({ txt = Lident "[]" }, None) );
-      } ->
-          "createDOMElementVariadic"
-      (* [@JSX] div(~children= value), coming from <div> ...(value) </div> *)
-      | _ ->
-          raise
-            (Invalid_argument
-               "A spread as a DOM element's children don't make sense written \
-                together. You can simply remove the spread.")
+    let keyProps, nonChildrenProps =
+      List.partition
+        (fun (arg_label, _) -> "key" = getLabel arg_label)
+        nonChildrenProps
     in
-    let args =
-      match nonChildrenProps with
-      | [ _justTheUnitArgumentAtEnd ] ->
-          [
-            (* "div" *)
-            (nolabel, componentNameExpr);
-            (* [|moreCreateElementCallsHere|] *)
-            (nolabel, childrenExpr);
-          ]
-      | nonEmptyProps ->
-          let propsCall =
-            Exp.apply ~loc
-              (Exp.ident ~loc
-                 { loc; txt = Ldot (Lident "ReactDOMRe", "domProps") })
-              (nonEmptyProps
-              |> List.map (fun (label, expression) ->
-                     (label, mapper#expression ctxt expression)))
-          in
-          [
-            (* "div" *)
-            (nolabel, componentNameExpr);
-            (* ReactDOMRe.props(~className=blabla, ~foo=bar, ()) *)
-            (labelled "props", propsCall);
-            (* [|moreCreateElementCallsHere|] *)
-            (nolabel, childrenExpr);
-          ]
+    let jsxExpr, args =
+      let jsxExpr, childrenProp =
+        jsxExprAndChildren ~ident:"ReactDOM" ~loc ~ctxt mapper ~keyProps
+          children
+      in
+
+      let propsCall =
+        Exp.apply ~loc
+          (Exp.ident ~loc { loc; txt = Ldot (Lident "JsxDOM", "domProps") })
+          ((match childrenProp with
+           | Some childrenProp ->
+               (labelled "children", childrenProp) :: nonChildrenProps
+           | None -> nonChildrenProps)
+          |> List.map (fun (label, expression) ->
+                 (label, mapper#expression ctxt expression)))
+      in
+      (jsxExpr, [ (nolabel, componentNameExpr); (nolabel, propsCall) ])
     in
-    Exp.apply
-      ~loc (* throw away the [@JSX] attribute and keep the others, if any *)
-      ~attrs
-      (* ReactDOMRe.createElement *)
-      (Exp.ident ~loc
-         { loc; txt = Ldot (Lident "ReactDOMRe", createElementCall) })
-      args
-    [@@raises Invalid_argument]
+    Exp.apply ~loc ~attrs jsxExpr args
   in
 
   let rec recursivelyTransformNamedArgsForMake ~ctxt mapper expr list =
@@ -540,8 +538,8 @@ let jsxMapper =
                   Ocaml_common.Location.prerr_warning pattern.ppat_loc
                     (Preprocessor
                        (Printf.sprintf
-                          "ReasonReact: optional argument annotations must \
-                           have explicit `option`. Did you mean \
+                          "react-jsx-ppx: optional argument annotations must \
+                           have an explicit `option` type. Did you mean \
                            `option(%s)=?`?"
                           currentType)))
           | _ -> ()
@@ -578,8 +576,8 @@ let jsxMapper =
         (list, Some txt)
     | Pexp_fun (Nolabel, _, pattern, _expression) ->
         Location.raise_errorf ~loc:pattern.ppat_loc
-          "ReasonReact: react.component refs only support plain arguments and \
-           type annotations."
+          "react-jsx-ppx: react.component refs only support plain arguments \
+           and type annotations."
     | _ -> (list, None)
     [@@raises Invalid_argument]
   in
@@ -740,7 +738,8 @@ let jsxMapper =
             in
             let modifiedBindingOld binding =
               let expression = binding.pvb_expr in
-              (* TODO: there is a long-tail of unsupported features inside of blocks - Pexp_letmodule , Pexp_letexception , Pexp_ifthenelse *)
+              (* TODO: there is a long-tail of unsupported features inside of
+                 blocks - Pexp_letmodule , Pexp_letexception , Pexp_ifthenelse *)
               let rec spelunkForFunExpression expression =
                 match expression with
                 (* let make = (~prop) => ... *)
@@ -789,7 +788,8 @@ let jsxMapper =
                     unerasableIgnore emptyLoc :: exp.pexp_attributes;
                 }
               in
-              (* TODO: there is a long-tail of unsupported features inside of blocks - Pexp_letmodule , Pexp_letexception , Pexp_ifthenelse *)
+              (* TODO: there is a long-tail of unsupported features inside of
+                 blocks - Pexp_letmodule , Pexp_letexception , Pexp_ifthenelse *)
               let rec spelunkForFunExpression expression =
                 match expression with
                 (* let make = (~prop) => ... with no final unit *)
@@ -844,11 +844,11 @@ let jsxMapper =
                       ((fun a -> a), false, unerasableIgnoreExp expression)
                     else
                       Location.raise_errorf ~loc:pattern.ppat_loc
-                        "ReasonReact: props need to be labelled arguments.\n\
+                        "react-jsx-ppx: props need to be labelled arguments.\n\
                         \  If you are working with refs be sure to wrap with \
                          React.forwardRef.\n\
-                        \  If your component doesn't have any props use () or \
-                         _ instead of a name."
+                        \  If your component doesn't have any props, use () \
+                         (unit) or _ (wildcard) instead of a name."
                 (* let make = {let foo = bar in (~prop) => ...} *)
                 | { pexp_desc = Pexp_let (recursive, vbs, internalExpression) }
                   ->
@@ -1185,33 +1185,21 @@ let jsxMapper =
               (Invalid_argument
                  "JSX: `createElement` should be preceeded by a module name.")
         (* Foo.createElement(~prop1=foo, ~prop2=bar, ~children=[], ()) *)
-        | { loc; txt = Ldot (modulePath, ("createElement" | "make")) } -> (
-            match !jsxVersion with
-            | None | Some 3 ->
-                transformUppercaseCall3 ~ctxt ~caller:"make" modulePath mapper
-                  loc attrs callExpression callArguments
-            | Some _ ->
-                raise (Invalid_argument "JSX: the JSX version must be  3"))
+        | { loc; txt = Ldot (modulePath, ("createElement" | "make")) } ->
+            transformUppercaseCall3 ~ctxt ~caller:"make" modulePath mapper loc
+              attrs callExpression callArguments
         (* div(~prop1=foo, ~prop2=bar, ~children=[bla], ()) *)
         (* turn that into
-           ReactDOMRe.createElement(~props=ReactDOMRe.props(~props1=foo, ~props2=bar, ()), [|bla|]) *)
-        | { loc; txt = Lident id } -> (
-            match !jsxVersion with
-            | None | Some 3 ->
-                transformLowercaseCall3 ~ctxt mapper loc attrs callArguments id
-            | Some _ ->
-                raise (Invalid_argument "JSX: the JSX version must be 3"))
+           ReactDOMRe.createElement(~props=ReactDOMRe.props(~props1=foo,
+           ~props2=bar, ()), [|bla|]) *)
+        | { loc; txt = Lident id } ->
+            transformLowercaseCall3 ~ctxt mapper loc attrs callArguments id
         (* Foo.bar(~prop1=foo, ~prop2=bar, ~children=[], ()) *)
         (* Not only "createElement" or "make". See
            https://github.com/reasonml/reason/pull/2541 *)
-        | { loc; txt = Ldot (modulePath, anythingNotCreateElementOrMake) } -> (
-            match !jsxVersion with
-            | None | Some 3 ->
-                transformUppercaseCall3 ~ctxt
-                  ~caller:anythingNotCreateElementOrMake modulePath mapper loc
-                  attrs callExpression callArguments
-            | Some _ ->
-                raise (Invalid_argument "JSX: the JSX version must be  3"))
+        | { loc; txt = Ldot (modulePath, anythingNotCreateElementOrMake) } ->
+            transformUppercaseCall3 ~ctxt ~caller:anythingNotCreateElementOrMake
+              modulePath mapper loc attrs callExpression callArguments
         | { txt = Lapply _ } ->
             (* don't think there's ever a case where this is reached *)
             raise
@@ -1256,7 +1244,8 @@ let jsxMapper =
           | _, nonJSXAttributes ->
               transformJsxCall ~ctxt self callExpression callArguments
                 nonJSXAttributes)
-      (* is it a list with jsx attribute? Reason <>foo</> desugars to [@JSX][foo]*)
+      (* is it a list with jsx attribute? Reason <>foo</> desugars to
+         [@JSX][foo]*)
       | {
           pexp_desc =
             ( Pexp_construct
@@ -1275,7 +1264,7 @@ let jsxMapper =
           | _, nonJSXAttributes ->
               let fragment =
                 Exp.ident ~loc
-                  { loc; txt = Ldot (Lident "ReasonReact", "fragment") }
+                  { loc; txt = Ldot (Lident "React", "jsxFragment") }
               in
               let childrenExpr =
                 transformChildrenIfList ~loc ~ctxt ~mapper:self listItems
@@ -1294,7 +1283,7 @@ let jsxMapper =
                 ~attrs:nonJSXAttributes
                 (* ReactDOMRe.createElement *)
                 (Exp.ident ~loc
-                   { loc; txt = Ldot (Lident "ReactDOMRe", "createElement") })
+                   { loc; txt = Ldot (Lident "ReactDOM", "createElement") })
                 args)
       (* Delegate to the default mapper, a deep identity traversal *)
       | e -> super#expression ctxt e
diff --git a/test/react.t b/test/react.t
index a6945b6609..e89fffb851 100644
--- a/test/react.t
+++ b/test/react.t
@@ -17,10 +17,13 @@ Demonstrate how to use the React JSX PPX
   > module React = {
   >   let array = Obj.magic
   >   let string = Obj.magic
-  >   let createElement = Obj.magic
+  >   let jsx = Obj.magic
   > };
-  > module ReactDOMRe = {
-  >   let createDOMElementVariadic = Obj.magic
+  > module JsxDOM = {
+  >   let domProps = Obj.magic
+  > };
+  > module ReactDOM = {
+  >   let jsx = Obj.magic
   > };
   > module App = {
   >   [@react.component]
